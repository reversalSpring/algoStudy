## 19. 비트 조작  
  
  
### 부울 대수  
> 떤 명제의 참과 거짓을 이진수 1과 0에 대응시켜서 명제와 명제간의 관계를 수학적으로 표현하는 것  
```  
>>> bool(1)  
True  
>>> bool(0)  
False  
>>> bool(1.5)  
True  
>>> bool('False')  
True  
```  
--> 즉, 정수 0, 실수 0.0이외의 모든 숫자는 True입니다. 그리고 빈 문자열 '', ""를 제외한 모든 문자열은 True입니다.  
  
### 부울 연산자 (논리 연산자)  
- AND : 두 값이 모두 참이라야 참  
- OR : 값 중 하나만 참  
- NOT : 논릿값을 뒤집는다.  
- XOR : 두 값중 정확히 하나만 참이어야, 혹은 두 값의 참거짓 여부가 다를 때 참  
-- 연산자들을 조합하여 다른 보조연산을 만들 수 있다.  
    
[부울 연산자]
![IMG_72688E797409-1](https://user-images.githubusercontent.com/30167661/116816009-3d338800-ab9b-11eb-8efd-c76702192c11.jpeg)

  
### 비트 연산자  
| 연산자 | 설명                                             |  
| ------ | ------------------------------------------------ |  
| &      | a와 b의 비트를 AND 연산                          |  
| \|     | a와 b의 비트를 OR연산                            |  
| ^      | a와 b의 비트를 XOR 연산(배타적 OR, Exclusive OR) |  
| ~      | x = -x -1                                        |  
| <<     | a의 비트를 b번 왼쪽으로 이동시킴                 |  
| >>     | a의 비트를 b번 오른쪽으로 이동시킴               |  
| &=     | a와 b의 비트를 &연산한 후 결과를 a에 할당        |  
| \|=    | a와 b의 비트를 \|연산한 후 결과를 a에 할당       |  
| ^=     | a와 b의 비트를 ^연산한 후 결과를 a에 할당        |  
| <<=    | a와 b의 비트를 <<연산한 후 결과를 a에 할당       |  
| >>=    | a와 b의 비트를 >>연산한 후 결과를 a에 할당       |  

### 비트 퀴즈
```  
>>> bin(0b0110 + 0b0010)
'0b1000'
>>> bin(0b0011 * 0b0101)  
'0b1111'
>>> bin(0b1101 >> 2) 
'0b11'
>>> bin(0b1101 << 2) 
'0b110100'
>>> bin(0b0101 ^ ~0b1100)
'-0b1010'
--> ~x = -x -1 --> -12 -1 --> -13 이므로
--> 만약 0b1100 --> 0b0011로 바꾸려면 MASK(자릿수 최대값)로 XOR
```  

[이진수 곱샘]
![IMG_614D047BFE95-1](https://user-images.githubusercontent.com/30167661/116816024-4c1a3a80-ab9b-11eb-837b-f6e7eb78dea6.jpeg)


### 진법 표현

#### 파이썬 진법 변환
```  
>>> bin(87)
'0b1010111'
>>> int('0b1010111', 2)
87

>>> a = bin(87)
>>> a
'0b1010111'
>>> type(a)
<class 'str'>

>>> b = 0b1010111
>>> b
87
>>> type(b)
<class 'int'>

>>> hex(87)
'0x57'
>>> c = 0x57
>>> c
87
```  

#### 파이썬에서 2의 보수
- 컴퓨터가 음수를 저장하기 위해 일반적으로 취하는 여러 방법 중 하나
- 파이썬은 임의 정밀도를 지원하기 때문에 내부적으론 복잡
- 부호는 별도의 필드로 갖고 있고 음수를 보여줄 때는 부호만 보여준다. (2의 보수를 실제로 보여주지 않는다.)
- 연산이 필요할 때만 2의 보수로 변환 작업을 함

#### 2의 보수 파이썬 vs 수학 연산
- [파이썬] 파이썬 비트 연산자 NOT은 2의 보수에서 1을 뺀 것
- [수학적 정의] 2의 보수 수학 연산은 비트 연산자 NOT에서 1을 더한 것 (1의 보수에 + 1)

```  
>>> bin(0b0101 ^ ~0b1100)
'-0b1010'
--> Ob1100 은 -4가 아니고 양수 12

[8비트 포맷으로 직접 계산]
>>> bin(0b00000101 ^ ~0b00001100)
'-0b1010'
--> bin(0b00000101 ^ 0b11110011) = '0b11110110' --> -10 동일

```  
